---
title: "Application of SCEPTRE to a small example dataset"
authors: Tim Barry, Gene Katsevich, Kathryn Roeder
output: html_vignette
vignette: >
  %\VignetteIndexEntry{Application of SCEPTRE to a small example dataset}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette illustrates the application of SCEPTRE to a small single-cell CRISPR screen dataset. Our data come from the study [A Genome-wide Framework for Mapping Gene Regulation via Cellular Genetic Screens](https://www.cell.com/cell/fulltext/S0092-8674(18)31554-X?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS009286741831554X%3Fshowall%3Dtrue), published by Gasperini et al. in 2019. The authors used CRISPR to perturb candidate enhancers of cells and assessed the impact of these perturbations via scRNA-seq. Our goal in this vignette is to determine the impact of a single perturbation on a single gene, accounting for appropriate technical factors. The perturbation and gene that we investigate were selected from the set of all perturbations and genes in the Gasperini dataset.

In our analysis of the Gasperini dataset in Katsevich et al. 2020, we processed all gene-gRNA pairs simultaneously. This large-scale approach allowed us to (i) regularize the negative binomial regression test statistic by pooling information across genes, and (ii) recycle certain repetitive computations, thereby accelerating program execution times. This small-scale example serves as a useful demonstration of SCEPTRE, but it does not reflect how one would apply SCEPTRE in practice. Please see the Github repository for information on reproducing the large-scale analysis reported in Katsevich et al. 2020.

We begin by loading the package and data.

```{r, message=FALSE}
library(sceptre)
data("expressions")
data("gRNA_indicators")
data("covariate_matrix")
```

The *expressions* vector contains the gene expressions (in UMIs); the *gRNA_indicator* vector records whether the gRNA was present or absent in a given cell; and the *covariate_matrix* records cell-specific technical factors (fraction of UMIs that map to mitochondrial genes, sequencing batch, log-transformed total UMI count across genes, log-transformed total number of detected gRNAs, and log-transformed total genes expressed). There are 205,797 cells in the data. Let's take a peek at the data by calling the *head* function.

```{r}
head(expressions)
head(gRNA_indicators)
head(covariate_matrix)
```

Next, we run the SCEPTRE algorithm by calling the function *run_sceptre_gRNA_gene_pair*. This function returns a *p*-value corresponding to the null hypothesis that the perturbation does not impact gene expression, accounting for the technical factors. This function is for illustration purposes only. When analyzing a large dataset consisting of many gene-gRNA pairs, we would leverage other **sceptre** functions that more efficiently recycle computation.

```{r}
result <- run_sceptre_gRNA_gene_pair(expressions = expressions, 
                                      gRNA_indicators = gRNA_indicators, 
                                      covariate_matrix = covariate_matrix,
                                      B = 500,
                                      seed = 1234)
```
We can examine the *p*-value.

```{r}
result %>% pull(p_value)
```

We also can examine the parameters of the fitted skew-t distribution used to compute the *p*-value.

```{r}
result %>% select(xi, omega, alpha, nu)
```

Given that the computed *p*-value (*p* = 0.16) exceeds our pre-chosen significance threshold of 0.05, we retain our null hypothesis that the perturbation does not affect gene expression. In practice, when analyzing a large dataset, we would apply a Benjamini-Hochberg correction to all gene-gRNA pairs and use a more liberal threshold to determine significance.
